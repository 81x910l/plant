## Generated by RcppR6 (0.1): do not edit by hand

##' @importFrom Rcpp evalCpp
##' @importFrom R6 R6Class
##' @useDynLib tree2
NULL


`Lorenz` <- function(sigma, R, b) {
  Lorenz__ctor(sigma, R, b)
}
.R6_Lorenz <-
  R6::R6Class("Lorenz",
              portable=TRUE,
              inherit=NULL,
              public=list(
                .ptr=NULL,
                initialize = function(ptr) {
                  self$.ptr <- ptr
                }),
              active=list(
                size = function(value) {
                  if (missing(value)) {
                    Lorenz__size__get(self)
                  } else {
                    stop("Lorenz$size is read-only")
                  }
                },
                ode_values = function(value) {
                  if (missing(value)) {
                    Lorenz__ode_values__get(self)
                  } else {
                    Lorenz__ode_values__set(self, value)
                  }
                },
                ode_rates = function(value) {
                  if (missing(value)) {
                    Lorenz__ode_rates__get(self)
                  } else {
                    stop("Lorenz$ode_rates is read-only")
                  }
                },
                pars = function(value) {
                  if (missing(value)) {
                    Lorenz__pars__get(self)
                  } else {
                    stop("Lorenz$pars is read-only")
                  }
                }))


OdeSystem <- function(T) {
  type <- c(T)
  valid <- list("OdeSystem<Lorenz>"="Lorenz")
  constructors <- list("OdeSystem<Lorenz>"=`OdeSystem<Lorenz>`)
  constructors[[check_type(type, valid)]]
}
.R6_OdeSystem <- R6::R6Class("OdeSystem")


`OdeSystem<Lorenz>` <- function(obj, abs_tol=1e-8, rel_tol=1e-8) {
  OdeSystem___Lorenz__ctor(obj, abs_tol, rel_tol)
}
.R6_OdeSystem___Lorenz <-
  R6::R6Class("OdeSystem<Lorenz>",
              portable=TRUE,
              inherit=.R6_OdeSystem,
              public=list(
                .ptr=NULL,
                initialize = function(ptr) {
                  self$.ptr <- ptr
                },
                do_step = function(dt) {
                  OdeSystem___Lorenz__do_step(self, dt)
                },
                try_step = function(dt) {
                  OdeSystem___Lorenz__try_step(self, dt)
                },
                advance = function(t, dt) {
                  OdeSystem___Lorenz__advance(self, t, dt)
                },
                advance_save = function(t, dt) {
                  OdeSystem___Lorenz__advance_save(self, t, dt)
                }),
              active=list(
                obj = function(value) {
                  if (missing(value)) {
                    OdeSystem___Lorenz__obj__get(self)
                  } else {
                    stop("OdeSystem<Lorenz>$obj is read-only")
                  }
                },
                t = function(value) {
                  if (missing(value)) {
                    OdeSystem___Lorenz__t__get(self)
                  } else {
                    OdeSystem___Lorenz__t__set(self, value)
                  }
                },
                y = function(value) {
                  if (missing(value)) {
                    OdeSystem___Lorenz__y__get(self)
                  } else {
                    OdeSystem___Lorenz__y__set(self, value)
                  }
                }))


`CohortScheduleEvent` <- function(introduction, species_index) {
  CohortScheduleEvent__ctor(introduction, species_index)
}
.R6_CohortScheduleEvent <-
  R6::R6Class("CohortScheduleEvent",
              portable=TRUE,
              inherit=NULL,
              public=list(
                .ptr=NULL,
                initialize = function(ptr) {
                  self$.ptr <- ptr
                }),
              active=list(
                species_index = function(value) {
                  if (missing(value)) {
                    CohortScheduleEvent__species_index__get(self)
                  } else {
                    stop("CohortScheduleEvent$species_index is read-only")
                  }
                },
                times = function(value) {
                  if (missing(value)) {
                    CohortScheduleEvent__times__get(self)
                  } else {
                    stop("CohortScheduleEvent$times is read-only")
                  }
                },
                time_introduction = function(value) {
                  if (missing(value)) {
                    CohortScheduleEvent__time_introduction__get(self)
                  } else {
                    stop("CohortScheduleEvent$time_introduction is read-only")
                  }
                },
                time_end = function(value) {
                  if (missing(value)) {
                    CohortScheduleEvent__time_end__get(self)
                  } else {
                    stop("CohortScheduleEvent$time_end is read-only")
                  }
                }))

##' Control parameters that tune various aspects of the numerical solvers.
##' @title Control parameters
##' @param ...,values Values to initialise the struct with (either as
##' variadic arguments, or as a list, but not both).
##' @export
Control <- function(..., values=list(...)) {
  ret <- Control__ctor()
  if (length(err <- setdiff(names(values), names(ret))) > 0L) {
    stop(sprintf("Unknown fields: %s", paste(err, collapse=", ")))
  }
  to_set <- intersect(names(values), names(ret))
  ret[to_set] <- values[to_set]
  ret
}

## This section of code is only included where templated classes are
## included.  Don't rely on the approach taken here, as it may change
## soon.
check_type <- function(type, valid) {
  i <- match(list(type), valid, nomatch=NA)
  if (is.na(i)) {
    choices <- paste(sprintf("\t%s", sapply(valid, paste, collapse=", ")),
                     collapse="\n")
    stop(sprintf("Invalid type '%s'; expected one of:\n%s",
                 paste(type, collapse=", "), choices))
  }
  names(valid)[[i]]
}
